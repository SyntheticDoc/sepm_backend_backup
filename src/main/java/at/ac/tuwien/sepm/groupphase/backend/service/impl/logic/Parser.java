
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package at.ac.tuwien.sepm.groupphase.backend.service.impl.logic;

import java_cup.runtime.*;
import java.util.Set;
import java.util.HashSet;
import at.ac.tuwien.sepm.groupphase.backend.service.impl.logic.ParserLiteralList;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
 */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

    public final Class getSymbolContainer() {
        return sym.class;
    }

    /** Default constructor. */
    @Deprecated
    public Parser() {super();}

    /** Constructor which sets the default scanner. */
    @Deprecated
    public Parser(java_cup.runtime.Scanner s) {super(s);}

    /** Constructor which sets the default scanner. */
    public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

    /** Production table. */
    protected static final short _production_table[][] =
        unpackFromStrings(new String[] {
            "\000\022\000\002\002\005\000\002\002\004\000\002\002" +
                "\005\000\002\002\005\000\002\002\004\000\002\002\005" +
                "\000\002\002\003\000\002\002\003\000\002\002\005\000" +
                "\002\002\005\000\002\002\006\000\002\002\005\000\002" +
                "\002\006\000\002\003\003\000\002\003\005\000\002\004" +
                "\004\000\002\005\005\000\002\005\002" });

    /** Access to production table. */
    public short[][] production_table() {return _production_table;}

    /** Parse-action table. */
    protected static final short[][] _action_table =
        unpackFromStrings(new String[] {
            "\000\044\000\016\004\006\007\005\014\012\017\004\020" +
                "\010\021\013\001\002\000\020\002\ufffb\005\ufffb\006\ufffb" +
                "\010\ufffb\013\ufffb\015\ufffb\016\ufffb\001\002\000\016\004" +
                "\006\007\005\014\012\017\004\020\010\021\013\001\002" +
                "\000\016\004\006\007\005\014\012\017\004\020\010\021" +
                "\013\001\002\000\010\011\033\012\034\013\032\001\002" +
                "\000\024\002\ufff4\005\ufff4\006\ufff4\010\ufff4\011\ufff4\012" +
                "\ufff4\013\ufff4\015\ufff4\016\ufff4\001\002\000\012\002\031" +
                "\005\020\006\022\013\021\001\002\000\016\004\006\007" +
                "\005\014\012\017\004\020\010\021\013\001\002\000\020" +
                "\002\ufffa\005\ufffa\006\ufffa\010\ufffa\013\ufffa\015\ufffa\016" +
                "\ufffa\001\002\000\004\015\030\001\002\000\014\005\020" +
                "\006\022\013\021\015\ufff0\016\016\001\002\000\016\004" +
                "\006\007\005\014\012\017\004\020\010\021\013\001\002" +
                "\000\004\015\ufff2\001\002\000\016\004\006\007\005\014" +
                "\012\017\004\020\010\021\013\001\002\000\016\004\006" +
                "\007\005\014\012\017\004\020\010\021\013\001\002\000" +
                "\016\004\006\007\005\014\012\017\004\020\010\021\013" +
                "\001\002\000\020\002\uffff\005\uffff\006\uffff\010\uffff\013" +
                "\uffff\015\uffff\016\uffff\001\002\000\020\002\ufffe\005\020" +
                "\006\022\010\ufffe\013\ufffe\015\ufffe\016\ufffe\001\002\000" +
                "\020\002\001\005\001\006\001\010\001\013\001\015\001" +
                "\016\001\001\002\000\014\005\020\006\022\013\021\015" +
                "\ufff0\016\016\001\002\000\004\015\ufff1\001\002\000\024" +
                "\002\ufff3\005\ufff3\006\ufff3\010\ufff3\011\ufff3\012\ufff3\013" +
                "\ufff3\015\ufff3\016\ufff3\001\002\000\004\002\000\001\002" +
                "\000\006\014\012\020\010\001\002\000\010\013\040\014" +
                "\012\020\010\001\002\000\010\013\035\014\012\020\010" +
                "\001\002\000\006\014\012\020\010\001\002\000\020\002" +
                "\ufff6\005\ufff6\006\ufff6\010\ufff6\013\ufff6\015\ufff6\016\ufff6" +
                "\001\002\000\020\002\ufff5\005\ufff5\006\ufff5\010\ufff5\013" +
                "\ufff5\015\ufff5\016\ufff5\001\002\000\006\014\012\020\010" +
                "\001\002\000\020\002\ufff8\005\ufff8\006\ufff8\010\ufff8\013" +
                "\ufff8\015\ufff8\016\ufff8\001\002\000\020\002\ufff7\005\ufff7" +
                "\006\ufff7\010\ufff7\013\ufff7\015\ufff7\016\ufff7\001\002\000" +
                "\020\002\ufff9\005\ufff9\006\ufff9\010\ufff9\013\ufff9\015\ufff9" +
                "\016\ufff9\001\002\000\020\002\ufffd\005\ufffd\006\ufffd\010" +
                "\ufffd\013\ufffd\015\ufffd\016\ufffd\001\002\000\012\005\020" +
                "\006\022\010\046\013\021\001\002\000\020\002\ufffc\005" +
                "\ufffc\006\ufffc\010\ufffc\013\ufffc\015\ufffc\016\ufffc\001\002" +
                "" });

    /** Access to parse-action table. */
    public short[][] action_table() {return _action_table;}

    /** <code>reduce_goto</code> table. */
    protected static final short[][] _reduce_table =
        unpackFromStrings(new String[] {
            "\000\044\000\006\002\010\003\006\001\001\000\002\001" +
                "\001\000\006\002\044\003\006\001\001\000\006\002\043" +
                "\003\006\001\001\000\002\001\001\000\002\001\001\000" +
                "\002\001\001\000\010\002\014\003\006\004\013\001\001" +
                "\000\002\001\001\000\002\001\001\000\004\005\016\001" +
                "\001\000\006\002\025\003\006\001\001\000\002\001\001" +
                "\000\006\002\024\003\006\001\001\000\006\002\023\003" +
                "\006\001\001\000\006\002\022\003\006\001\001\000\002" +
                "\001\001\000\002\001\001\000\002\001\001\000\004\005" +
                "\026\001\001\000\002\001\001\000\002\001\001\000\002" +
                "\001\001\000\004\003\042\001\001\000\004\003\040\001" +
                "\001\000\004\003\035\001\001\000\004\003\036\001\001" +
                "\000\002\001\001\000\002\001\001\000\004\003\041\001" +
                "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
                "\000\002\001\001\000\002\001\001\000\002\001\001" });

    /** Access to <code>reduce_goto</code> table. */
    public short[][] reduce_table() {return _reduce_table;}

    /** Instance of action encapsulation class. */
    protected CUP$Parser$actions action_obj;

    /** Action encapsulation object initializer. */
    protected void init_actions()
    {
        action_obj = new CUP$Parser$actions(this);
    }

    /** Invoke a user supplied parse action. */
    public java_cup.runtime.Symbol do_action(
        int                        act_num,
        java_cup.runtime.lr_parser parser,
        java.util.Stack            stack,
        int                        top)
        throws java.lang.Exception
    {
        /* call code in generated class */
        return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
    }

    /** Indicates start state. */
    public int start_state() {return 0;}
    /** Indicates start production. */
    public int start_production() {return 1;}

    /** <code>EOF</code> Symbol index. */
    public int EOF_sym() {return 0;}

    /** <code>error</code> Symbol index. */
    public int error_sym() {return 1;}



    public boolean syntaxErrors;

    public void syntax_error(Symbol current_token) {
        report_error(
            "Syntax error at line " + (current_token.left+1) + ", column "
                + current_token.right, null
        );
    }

    private Set<Long> positives = new HashSet<Long>();

    public void setVariable(Set<Long> variables)
    {
        positives = variables;
    }


    /** Cup generated class to encapsulate user supplied action code.*/
    @SuppressWarnings({"rawtypes", "unchecked", "unused"})
    class CUP$Parser$actions {
        private final Parser parser;

        /** Constructor */
        CUP$Parser$actions(Parser parser) {
            this.parser = parser;
        }

        /** Method 0 with the actual generated action code for actions 0 to 300. */
        public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
            int                        CUP$Parser$act_num,
            java_cup.runtime.lr_parser CUP$Parser$parser,
            java.util.Stack            CUP$Parser$stack,
            int                        CUP$Parser$top)
            throws java.lang.Exception
        {
            /* Symbol object for return from actions */
            java_cup.runtime.Symbol CUP$Parser$result;

            /* select the action based on the action number */
            switch (CUP$Parser$act_num)
            {
                /*. . . . . . . . . . . . . . . . . . . .*/
                case 0: // expr ::= expr AND expr
                {
                    Boolean RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Boolean e1 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Boolean e2 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = e1 && e2;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 1: // $START ::= expr EOF
                {
                    Object RESULT =null;
                    int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
                    int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
                    Boolean start_val = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
                    RESULT = start_val;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                /* ACCEPT */
                CUP$Parser$parser.done_parsing();
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 2: // expr ::= expr OR expr
                {
                    Boolean RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Boolean e1 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Boolean e2 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = e1 || e2;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 3: // expr ::= expr EQUALS expr
                {
                    Boolean RESULT =null;
                    int e1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int e1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Boolean e1 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int e2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int e2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Boolean e2 = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = e1 == e2;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 4: // expr ::= NOT expr
                {
                    Boolean RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Boolean e = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = !e;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 5: // expr ::= BL expr BR
                {
                    Boolean RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
                    Boolean e = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
                    RESULT = e;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 6: // expr ::= LITERAL
                {
                    Boolean RESULT =null;
                    int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = b;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 7: // expr ::= VARIABLE
                {
                    Boolean RESULT =null;
                    int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Long v = (Long)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = positives.contains(v);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 8: // expr ::= term EQUALS term
                {
                    Boolean RESULT =null;
                    int t1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int t1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Integer t1 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int t2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int t2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer t2 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = (t1 == t2);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 9: // expr ::= term GREATER term
                {
                    Boolean RESULT =null;
                    int t1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int t1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Integer t1 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int t2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int t2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer t2 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = (t1 > t2);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 10: // expr ::= term GREATER EQUALS term
                {
                    Boolean RESULT =null;
                    int t1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
                    int t1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
                    Integer t1 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
                    int t2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int t2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer t2 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = (t1 >= t2);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 11: // expr ::= term SMALLER term
                {
                    Boolean RESULT =null;
                    int t1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
                    int t1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
                    Integer t1 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
                    int t2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int t2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer t2 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = (t1 < t2);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 12: // expr ::= term SMALLER EQUALS term
                {
                    Boolean RESULT =null;
                    int t1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
                    int t1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
                    Integer t1 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
                    int t2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int t2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer t2 = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = (t1 <= t2);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expr",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 13: // term ::= NUMBER
                {
                    Integer RESULT =null;
                    int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    Integer n = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = n;
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 14: // term ::= AL expressions AR
                {
                    Integer RESULT =null;
                    int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
                    int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
                    ParserLiteralList l = (ParserLiteralList)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
                    RESULT = l.countTrue();
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("term",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 15: // expressions ::= expr commaexpressions
                {
                    ParserLiteralList RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
                    Boolean e = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    ParserLiteralList c = (ParserLiteralList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = c; c.add(e);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("expressions",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 16: // commaexpressions ::= COMMA expr commaexpressions
                {
                    ParserLiteralList RESULT =null;
                    int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
                    int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
                    Boolean e = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
                    int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
                    int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
                    ParserLiteralList c = (ParserLiteralList)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
                    RESULT = c; c.add(e);
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("commaexpressions",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /*. . . . . . . . . . . . . . . . . . . .*/
                case 17: // commaexpressions ::=
                {
                    ParserLiteralList RESULT =null;
                    RESULT = new ParserLiteralList();
                    CUP$Parser$result = parser.getSymbolFactory().newSymbol("commaexpressions",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
                }
                return CUP$Parser$result;

                /* . . . . . .*/
                default:
                    throw new Exception(
                        "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

            }
        } /* end of method */

        /** Method splitting the generated action code into several parts. */
        public final java_cup.runtime.Symbol CUP$Parser$do_action(
            int                        CUP$Parser$act_num,
            java_cup.runtime.lr_parser CUP$Parser$parser,
            java.util.Stack            CUP$Parser$stack,
            int                        CUP$Parser$top)
            throws java.lang.Exception
        {
            return CUP$Parser$do_action_part00000000(
                CUP$Parser$act_num,
                CUP$Parser$parser,
                CUP$Parser$stack,
                CUP$Parser$top);
        }
    }

}
